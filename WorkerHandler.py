import asyncio
from threading import Thread


class Status:
    DONE = 'DONE'
    UNDONE = 'UNDONE'
    ERROR = 'ERROR'


class Worker(object):
    def __init__(self, prepared_object):
        self.prepared_object = prepared_object
        self.method_call = self.is_async()
        self.event_loop = None

    def is_async(self) -> bool:
        return asyncio.isfuture(getattr(self.prepared_object, 'logic')) or \
               asyncio.iscoroutine(getattr(self.prepared_object, 'logic')) or \
               asyncio.iscoroutinefunction(getattr(self.prepared_object, 'logic'))

    def run(self):
        # if .logic is async #
        if self.method_call:
            # maybe we should not start every
            # coroutine in separate event loop ?
            self.event_loop = asyncio.new_event_loop()
        thread = Thread(target=self.runner(), args=())
        thread.run()

    def runner(self):
        if self.event_loop and self.method_call:
            self.event_loop.run_until_complete(getattr(self.prepared_object, "logic")())
        else:
            getattr(self.prepared_object, "logic")()
        if self.prepared_object.status() is None:
            print(f"Object: {self.prepared_object} does not have status. Changing it to DONE.")
            self.prepared_object.work_status = Status.DONE

        print(f"Object {self.prepared_object} done with status: {self.prepared_object.status()}")

        # We need to gracefully stop event loop
        # Because of threads can't handle this fd
        # and through RuntimeError with fd = -1
        if self.event_loop and self.method_call:
            if not self.event_loop.is_running():
                self.event_loop.close()
