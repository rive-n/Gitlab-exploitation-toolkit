from WorkerHandler import Worker, Status
from ListImpl import LinkedListNode, InheritedLinkedList


class Meta(type):
    __inherited__ = InheritedLinkedList()

    def __new__(mcs, name, bases, dct):
        new_object = super().__new__(mcs, name, bases, dct)
        mcs.__inherited__.append(new_object)
        return new_object


class Plugins(metaclass=Meta):

    def __init__(self):
        # Every plugin should inherit from this class
        # Every plugin should have this list of methods:
        # self.__init__ -> plugin setup, like: necessary object, libs etc
        # * self.__init__ should have attr named self.work_status
        # self.logic -> main method with logic
        # self.status -> DONE/UNDONE/ERROR
        # - self.trace -> if self.status == ERROR

        self.plugin_workers = []

    @staticmethod
    def __plugin_rules():
        methods_list = ['setup', 'logic', 'status', 'trace', 'parser']
        error_args = {}

        Meta.__inherited__.remove(Plugins)
        for plugin in Meta.__inherited__:
            plugin = plugin.data # <- plugin.data is <class ... >
            if all(methods in dir(plugin) and callable(getattr(plugin, methods)) for methods in methods_list):
                print(f"[+] Plugin validated: {plugin} ")
            else:
                Meta.__inherited__.remove(plugin)
                plug_name = str(plugin)
                error_args.update({plug_name: []})
                args = [arg for arg in methods_list if arg not in dir(plugin)]
                error_args[plug_name] += args
        for error_name, methods_largs in error_args.items():
            print(f"[-] Plugin {error_name}, no methods: {', '.join(methods_largs)} or objects are not callable.")

    def __plugins_parsers(self):
        pass

    def __start_workers(self):
        for plugin in Meta.__inherited__:
            self.plugin_workers.append(
                Worker(plugin.data()))
        for work in self.plugin_workers:
            work.run()

    def setup(self):
        self.__plugin_rules()
        self.__start_workers()


class ArgumentsParserPlugin(Plugins):

    def __init__(self):
        super().__init__()
        self.work_status = None

    def setup(self):
        print(self.__dir__())

    def trace(self):
        pass

    def logic(self):
        print(f"Hello from: {type(self).mro()}")
        self.work_status = Status.DONE

    def status(self):
        return self.work_status


class AnotherPlugin(Plugins):
    def __init__(self):
        super().__init__()
        self.work_status = None

    def setup(self):
        print(self.__dir__())

    async def logic(self):
        print(f"Hello from: {type(self).mro()}")

    def trace(self):
        pass

    def status(self):
        return self.work_status

    def parser(self):
        pass
