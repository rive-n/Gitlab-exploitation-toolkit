import argparse


class ArgumentParser(object):
    """
    # Every plugin should have
    # - self._parser method
    # with logic containing
    # argparse object. This
    # object will be recreated
    # in scope of parent main
    # parser. So basically we are
    # using your plugin parser to create
    # default parses for whole tool.

    # The only problem is in conflict
    # The only way (as i think) is to use
    # conflict_handler='resolve' handler
    # that will by default resolve all
    # conflicts in the program.

    # If you don't want to auto editing,
    # just inherit from this class and change
    # parser options like this:
    # https://docs.python.org/3/library/argparse.html#other-utilities
    """

    def __init__(self):
        pass

    def __recreate_parser(self, created_parser):
        """
        Example parser ._actions:
        _HelpAction(option_strings=['-h', '--help'], dest='help', nargs=0, const=None, default='==SUPPRESS==', type=None,
        choices=None, help='show this help message and exit', metavar=None)
        _StoreAction(option_strings=['-t', '--test'], dest='test', nargs=None, const=None, default=None, type=None,
        choices=None, help=None, metavar=None)
        _StoreAction(option_strings=['-p', '--plugin'], dest='plugin', nargs=None, const=None, default=None, type=None,
        choices=None, help=None, metavar=None)

        So this method is created for recreation of parser to insert it into the "parent"
        :param created_parser:
        :return:
        """
        _actions = created_parser._actions  # <- getting "private" values of current parser
